\documentclass[a4paper,11pt,oneside,openany]{jsarticle}
    \usepackage[dvipdfmx]{graphicx}
    \usepackage{amsmath,amssymb}
    \usepackage{bm}
    \usepackage{graphicx}
    \usepackage{ascmac}
    
    \thispagestyle{empty}
    %
    \begin{document}
    \begin{center}
    
      \vspace*{35mm}
      \huge レポート2 \par
      \vspace{90mm}
      \Large 提出期限:2019/6/14\\
       提出日: \today \\
      \vspace{15mm}
      \Large 
       1029293806\hspace{5mm}大山 偉永\par
    
      \vspace{10mm}
    \end{center}
    \clearpage
    \addtocounter{page}{-1}
    
    \newpage

\subsection{Exercise3.2.1}
    ML1 インタプリタのプログラムをコンパイル・実行し，インタプリタの動 作を確かめよ．
    大域環境として i, v, x の値のみが定義されているが，ii が 2，iii が 3，iv が 4 となるようにプログラムを変更して，
    動作を確かめよ.\\\\
    ML1 インタプリタの実装は与えられた例のコードをコピーすれば実行できる。プログラムの説明はコード内に記す。
    cui.mlの環境をメソッドextendによって拡張子iiに2、iiiに3、ivに4を束縛させた。
    実際にインタプリタを立ち上げてii+iii+ivを実行すると\\
    $val\ -\ =\ 9$が返ってくる。

\subsection{Exercise3.2.2}
    不正な入力を与え た場合，適宜メッセージを出力して，インタプリタプロンプトに戻るように改造せよ.\\\\
    cui.mlにおいて大域環境を読み込み入力された値を評価する部分を関数として定義し、
    その間にエラーが発生すればtry-with文により特定のメッセージを返し再び、その定義した関数を呼び出すように設計した。
    なおエラー文はひとつでも可能だが少し調べて３つに分けて出力できるようにした。
    特にEvalでのエラーをそのままインタプリタ上に表示するようにしたことで自分のデバッグもどこのエラーなのか判断しやすくなりいい改良だった。

\subsection{Exercise3.2.3}
    論理値演算のための二項演算子 &&, || を追加せよ． \\\\
    まずparserにおいて他の加算や乗算と同様にANDとORのtokenを宣言する。次にこれらの表現を定義するANDExprとORExprを実装する。
    ここで注意が必要なのが演算子&&と||において&&のほうが優先順位が高いためORExprがANDExprを内包するような形で定義する。
    そして&&より比較演算子のほうが演算適用優先順位が高いため比較演算を表すLTExprをANDExprが内包するように書く。
    syntax.mlでは抽象構文木のデータ型を定義する。&&と||に関してはすでに定義されているヴァリアント型BinOpにorとandの型を付加する。
    最後に解釈部eval.mlで構文木を評価する。プリミティブ演算を適用する部分の関数apply_primに変更を加える。
    この関数の引数opがsyntaxで定義したor型かand型かまたそれ以外かをパターンマッチで場合分けし評価する。
    ここで実際にocamlの&&,||演算子を用いてこのプリミティブ演算の評価を決定する。
    ここでテストケースのtrue||undefもしくはfalse&&underはそれぞれtrueとfalseを出力するように定義する必要があるので
    この場合に関しては関数eval_expないで評価する。評価するexp型の値が BinOp (op, exp1, exp2)型で
    かつそのときのopがorまたはandの時でexp1もしくはexp2がtrueもしくはfalseの時にそれぞれtrueとfalseを出力するように評価の決定を行う。
    ここでこのケースに対応しない場合、未定義のundef型が評価されてしまいundefがunbound valueとしてエラーが出てしまう。
    こうすることで&&と||の実装が完了した。
    
\subsection{Exercise3.2.3}
    lexer.mllを改造し，(*と*)で囲まれたコメントを読み飛ばすよう にせよ．\\\\
    これはlexerを変えるだけで実装が終わる。
    字句解析においてmainルールで(*が現れた時はヒントにあるように新たに自分でcommentルールを定義しそこに飛ぶようにする。
    ここでこの字句解析のルールは引数を取ることができ、はじめこのcommentルールに飛んだ時はその引数を0とする。
    このcommentルール内でさらに字句"(*"が現れた時はcomment\ 1を呼び出す。
    このようにコメント内で(*が現れるたびに引数を一つ大きくしたcommentルールを再帰的に呼び出す。
    逆に*)が現れた時はそのときの引数-1した引数のcommentルールを呼び出しその引数-1が0になったときにもとのmainルールに戻るように定義する。




\subsection{Exercise3.3.1}
    ML2 インタプリタを作成し，テストせよ．\\
    与えられたコードを所定の一にコピーアンドペーストすれば実行できる。プログラムの説明はコード内に記す。

\subsection{Exercise3.3.2}
    parser.mlyの文法規則toplevelのなかに LET\ x=ID\ EQ\ e=Expr\ top=toplevel\ {VarDecl(x,e,top)}を追加する。
    こうすることで上で追加した文法規則のtoplevelの部分が文法規則toplevelの中で
    別に定義されている文法規則LET\ x=ID\ EQ \e=Expr\ SEMISEMI\ { Decl (x, e) }を呼び出すことができ、
    let\ a\ =\ 3\ let\ b\ =\ 4;;のような定義もすることができるようになる。
    ここでLET\ x=ID\ EQ\ e=Expr\ top=toplevel\ {VarDecl(x,e,top)}のように書いてしまうことで
    parser上では




  

\end{ducument}